"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIViteAutoImport = void 0;
const path_1 = __importDefault(require("path"));
const util_1 = require("./util");
let btime = new Date().getTime();
const log = (str, time = false) => {
    console.log('');
    console.log('\u001b[42;30m ui-vite-auto-import \u001b[40;32m ' + str + ' \u001b[0m');
    if (time)
        console.log('耗时:', new Date().getTime() - btime);
    btime = new Date().getTime();
};
const tagList = ["VButton", "VSwitch", "VScale", "VMask", "VCircle", "VIcon", "VSelect", "VSIcon"];
const extractTags = (str) => {
    const regex = /<([a-zA-Z\-]+)(?=\s|>|\/>)/g;
    const tags = [];
    let match;
    while ((match = regex.exec(str)) !== null) {
        tags.push(match[1]);
    }
    return [
        ...new Set(tags.map((tag) => {
            tag = tag.replace(/-(\w)/g, (_, c) => c.toUpperCase());
            return tag.charAt(0).toUpperCase() + tag.slice(1);
        }))
    ];
};
const getTagList = (str, name) => {
    const re = new RegExp(`<${name}(.*?)<\/${name}>`, 'gs');
    return Array.from(re[Symbol.matchAll](str)).map((item) => {
        return item[0];
    });
};
const cmddir = path_1.default.resolve('./');
const conf = {
    src: path_1.default.resolve(path_1.default.join(cmddir, './src')),
    use: [],
    config: {},
    diy: {
        tablecolumn: {
            fixed: false
        }
    }
};
const init = async () => {
    await (0, util_1.readDir)(conf.src, async (location) => {
        if (location.substring(location.length - 3) === 'vue') {
            const ctx = await (0, util_1.readFile)(location);
            if (ctx) {
                const tags = extractTags(ctx);
                tags.forEach((tag) => {
                    if (tagList.includes(tag))
                        conf.use.push(tag);
                });
                if (ctx.indexOf('VTableColumn') != -1 && !conf.diy.tablecolumn.fixed) {
                    const _tarr = getTagList(ctx, 'VTableColumn');
                    for (let i = 0; i < _tarr.length; i++) {
                        const _str = _tarr[i];
                        if (_str.indexOf('fixed') != -1) {
                            conf.diy.tablecolumn.fixed = true;
                            break;
                        }
                    }
                }
            }
        }
    });
    const inludeList = conf.config.include;
    if (inludeList) {
        conf.use = conf.use.concat(inludeList.filter((_item) => tagList.includes(_item)));
    }
    conf.use = [...new Set(conf.use)];
    console.log(conf.use);
};
function UIViteAutoImport(config) {
    conf.config = config;
    const isBuild = config.isBuild;
    return {
        name: 'vite:ui-vite-auto-import',
        enforce: 'pre',
        async configResolved() {
            if (!isBuild)
                return;
            await init();
        },
        transform(code, id) {
            if (!isBuild)
                return;
            let comImport = path_1.default.resolve(id);
            comImport = comImport.replace(/[\/\\]/g, '#');
            if (comImport.indexOf('ui-vite#src#components.ts') != -1) {
                let res = '';
                conf.use.forEach((comName) => {
                    let _tname = comName;
                    if (_tname.indexOf('Table') != -1 && !conf.diy.tablecolumn.fixed) {
                        _tname += 'NoFixed';
                    }
                    res += `import './${_tname.substring(1)}/style.less';\n`;
                    res += `export * as ${comName} from './${_tname.substring(1)}/index.vue';\n`;
                });
                log('🥰🥰处理组件完毕');
                return res;
            }
        }
    };
}
exports.UIViteAutoImport = UIViteAutoImport;
