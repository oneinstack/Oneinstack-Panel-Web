// node_modules/tools-websocket/dist/tools-websocket.js
!function() {
  "use strict";
  function t(t2, e2, s2, i2) {
    return new (s2 || (s2 = Promise))(function(n2, o) {
      function r(t3) {
        try {
          h(i2.next(t3));
        } catch (t4) {
          o(t4);
        }
      }
      function a(t3) {
        try {
          h(i2.throw(t3));
        } catch (t4) {
          o(t4);
        }
      }
      function h(t3) {
        var e3;
        t3.done ? n2(t3.value) : (e3 = t3.value, e3 instanceof s2 ? e3 : new s2(function(t4) {
          t4(e3);
        })).then(r, a);
      }
      h((i2 = i2.apply(t2, e2 || [])).next());
    });
  }
  var e;
  "function" == typeof SuppressedError && SuppressedError, function(t2) {
    t2[t2.load = 0] = "load", t2[t2.open = 1] = "open", t2[t2.close = 2] = "close";
  }(e || (e = {}));
  class s {
    constructor(t2) {
      var e2, s2, i2, n2, o;
      this.failNum = 0, this.timer = null, this.start = () => {
        this.status && null === this.timer && (this.failNum = 0, this.timer = setInterval(() => {
          if (this.failNum >= this.heartFailNum)
            return this.stop(), void this.websocketbean.onerror();
          let t3 = this.heartSend;
          "function" == typeof this.heartSend && (t3 = this.heartSend(this.websocketbean.param)), this.websocketbean.websocket.send(t3), this.failNum++;
        }, this.heartGapTime));
      }, this.stop = () => {
        this.status && (clearInterval(this.timer), this.timer = null);
      }, this.onmessage = (t3) => {
        var e3, s3;
        if (this.status)
          if ("string" == typeof this.heartGet) {
            const i3 = null !== (e3 = this.websocketbean.param.messagePrefix) && void 0 !== e3 ? e3 : "", n3 = null !== (s3 = this.websocketbean.param.messageSuffix) && void 0 !== s3 ? s3 : "";
            t3 === i3 + this.heartGet + n3 && (this.failNum = 0);
          } else
            "function" == typeof this.heartGet && this.heartGet(this.websocketbean.param, t3) && (this.failNum = 0);
      }, this.websocketbean = t2, this.status = null !== (e2 = t2.param.needHeart) && void 0 !== e2 && e2, this.heartSend = null !== (s2 = this.websocketbean.param.heartSend) && void 0 !== s2 ? s2 : "heartSend", this.heartGet = null !== (i2 = this.websocketbean.param.heartGet) && void 0 !== i2 ? i2 : "heartGet", this.heartGapTime = null !== (n2 = this.websocketbean.param.heartGapTime) && void 0 !== n2 ? n2 : 3e4, this.heartFailNum = null !== (o = this.websocketbean.param.heartFailNum) && void 0 !== o ? o : 10;
    }
  }
  class i {
    constructor(t2) {
      var e2, s2, i2;
      this.num = 0, this.reconnectMaxNum = 10, this.reconnectGapTime = 3e4, this.timer = null, this.start = () => {
        this.status && null === this.timer && (this.num = 0, this.websocketbean.param.onreconnect && this.websocketbean.param.onreconnect(), this.timer = setInterval(() => {
          if (this.num >= this.reconnectMaxNum)
            return this.websocketbean.param.onFailReconnect && this.websocketbean.param.onFailReconnect(), void this.stop();
          this.websocketbean.start(), this.num++;
        }, this.reconnectGapTime));
      }, this.stop = () => {
        this.status && (clearInterval(this.timer), this.timer = null);
      }, this.websocketbean = t2, this.status = null !== (e2 = t2.param.needReconnect) && void 0 !== e2 && e2, this.reconnectMaxNum = null !== (s2 = this.websocketbean.param.reconnectMaxNum) && void 0 !== s2 ? s2 : 10, this.reconnectGapTime = null !== (i2 = this.websocketbean.param.reconnectGapTime) && void 0 !== i2 ? i2 : 3e4;
    }
  }
  const n = { WebSocketBean: class {
    constructor(n2) {
      this.status = null, this.websocket = null, this.heart = null, this.reconnect = null, this.onopen = () => t(this, void 0, void 0, function* () {
        this.reconnect.stop(), this.param.onopen && this.param.onopen(), this.status = e.open, this.heart.start();
      }), this.onmessage = (t2) => {
        this.param.onmessage && this.param.onmessage(t2), this.heart.onmessage(t2.data);
      }, this.onerror = () => {
        this.param.onerror && this.param.onerror(), this.close(), "hidden" != document.visibilityState ? this.reconnect.start() : this.hiddenReconnect = true;
      }, this.start = (t2) => {
        this.close(), t2 ? this.param = t2 : t2 = this.param, this.websocket = new WebSocket(t2.url), t2.binaryType || (t2.binaryType = "blob"), this.websocket.binaryType = t2.binaryType, this.status = e.load, this.websocket.onopen = this.onopen, this.websocket.onmessage = this.onmessage, this.websocket.onerror = this.onerror, this.websocket.onclose = this.onerror, this.heart = new s(this), null === this.reconnect && (this.reconnect = new i(this)), window.addEventListener("beforeunload", this.dispose);
      }, this.hiddenReconnectVisibility = () => {
        "hidden" != document.visibilityState && this.hiddenReconnect && (this.hiddenReconnect = false, this.reconnect.start());
      }, this.hiddenReconnect = false, this.send = (e2) => t(this, void 0, void 0, function* () {
        const s2 = this.param.sendPrefix, i2 = this.param.sendSuffix;
        if (!s2 && !i2)
          return void this.websocket.send(e2);
        const n3 = yield function(e3) {
          return t(this, void 0, void 0, function* () {
            if (null == e3)
              return { type: "string", data: e3 + "", str: e3 };
            if ("string" == typeof e3)
              return { type: "string", data: e3, str: e3 };
            if (e3 instanceof Blob)
              return new Promise((t2, s3) => {
                const i3 = new FileReader();
                i3.onloadend = () => t2({ type: "blob", data: e3, str: i3.result }), i3.onerror = s3, i3.readAsText(e3);
              });
            if (e3 instanceof ArrayBuffer) {
              const t2 = new TextDecoder("utf-8");
              return { type: "arraybuffer", data: e3, str: t2.decode(new Uint8Array(e3)) };
            }
            if ("object" == typeof e3 || Array.isArray(e3)) {
              const t2 = JSON.stringify(e3, (t3, e4) => {
                if ("function" != typeof e4 && void 0 !== e4)
                  return e4;
              });
              return { type: "object", data: e3, str: t2 };
            }
            throw new Error("Unsupported data type");
          });
        }(e2), o = yield function(e3, s3, i3, n4) {
          return t(this, void 0, void 0, function* () {
            const t2 = `${i3 || ""}${e3}${n4 || ""}`;
            return "blob" === s3 ? new Blob([t2], { type: "text/plain" }) : "arraybuffer" === s3 ? new TextEncoder().encode(t2).buffer : e3;
          });
        }(n3.str, n3.type, this.param.sendPrefix, this.param.sendSuffix);
        this.websocket.send(o);
      }), this.close = () => {
        null !== this.websocket && (window.removeEventListener("beforeunload", this.dispose), this.websocket && (this.websocket.onerror = null, this.websocket.onmessage = null, this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.close(), this.websocket = null), this.heart && (this.heart.stop(), this.heart = null), this.status = e.close);
      }, this.dispose = () => {
        this.close(), this.reconnect && (this.reconnect.stop(), this.reconnect = null), document.removeEventListener("visibilitychange", this.hiddenReconnectVisibility);
      }, this.param = n2, document.addEventListener("visibilitychange", this.hiddenReconnectVisibility);
    }
  } };
  Object.keys(n).forEach((t2) => {
    window[t2] = n[t2];
  });
}();
//# sourceMappingURL=tools-websocket.js.map
